name: Apply WSO2 IAM Update

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Select the Environment'
        required: true
        type: choice
        options:
          - 'DEV'
          - 'SIT'
          - 'UAT_NODE_1'
          - 'UAT_NODE_2'
        default: 'DEV'
      dry_run_path:
        description: 'Dry run conflicts path (from check workflow Teams notification)'
        required: true
        type: string
      auto_resolve_patterns:
        description: 'File patterns to auto-resolve by keeping ours (comma-separated). e.g. *.jsp,*.css'
        required: true
        type: string
        default: '*.jsp'

jobs:
  # ============================================================
  # Job 1: Validate inputs and pre-flight checks
  # ============================================================
  validate:
    name: Validate Inputs
    runs-on: [self-hosted, ansible]
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      ssh_host: ${{ steps.env-secrets.outputs.ssh_host }}
      ssh_user: ${{ steps.env-secrets.outputs.ssh_user }}
      ssh_pass: ${{ steps.env-secrets.outputs.ssh_pass }}
      inventory_file: ${{ steps.env-secrets.outputs.inventory_file }}
      group_vars_file: ${{ steps.env-secrets.outputs.group_vars_file }}
    steps:
      - name: Validate inputs
        run: |
          DRY_RUN_PATH="${{ inputs.dry_run_path }}"
          PATTERNS="${{ inputs.auto_resolve_patterns }}"

          if [ -z "$DRY_RUN_PATH" ]; then
            echo "::error::Dry run path is required"
            exit 1
          fi

          echo "Environment:           ${{ inputs.environment }}"
          echo "Dry Run Path:          $DRY_RUN_PATH"
          echo "Auto-resolve Patterns: $PATTERNS"

      - name: Determine environment
        id: env
        run: |
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT

      - name: Set environment-specific secrets
        id: env-secrets
        run: |
          ENVIRONMENT="${{ steps.env.outputs.environment }}"

          case "$ENVIRONMENT" in
            DEV)
              echo "ssh_host=${{ secrets.WSO2_HOST_DEV }}" >> $GITHUB_OUTPUT
              echo "ssh_user=${{ secrets.WSO2_SSH_USERNAME_DEV }}" >> $GITHUB_OUTPUT
              echo "ssh_pass=${{ secrets.WSO2_SSH_PASSWORD_DEV }}" >> $GITHUB_OUTPUT
              echo "inventory_file=DEV.yml" >> $GITHUB_OUTPUT
              echo "group_vars_file=DEV.yml" >> $GITHUB_OUTPUT
              ;;
            SIT)
              echo "ssh_host=${{ secrets.WSO2_HOST_SIT }}" >> $GITHUB_OUTPUT
              echo "ssh_user=${{ secrets.WSO2_SSH_USERNAME_SIT }}" >> $GITHUB_OUTPUT
              echo "ssh_pass=${{ secrets.WSO2_SSH_PASSWORD_SIT }}" >> $GITHUB_OUTPUT
              echo "inventory_file=SIT.yml" >> $GITHUB_OUTPUT
              echo "group_vars_file=SIT.yml" >> $GITHUB_OUTPUT
              ;;
            UAT_NODE_1)
              echo "ssh_host=${{ secrets.WSO2_HOST_UAT_NODE_1 }}" >> $GITHUB_OUTPUT
              echo "ssh_user=${{ secrets.WSO2_SSH_USERNAME_UAT_NODE_1 }}" >> $GITHUB_OUTPUT
              echo "ssh_pass=${{ secrets.WSO2_SSH_PASSWORD_UAT_NODE_1 }}" >> $GITHUB_OUTPUT
              echo "inventory_file=UAT_NODE_1.yml" >> $GITHUB_OUTPUT
              echo "group_vars_file=UAT_NODE_1.yml" >> $GITHUB_OUTPUT
              ;;
            UAT_NODE_2)
              echo "ssh_host=${{ secrets.WSO2_HOST_UAT_NODE_2 }}" >> $GITHUB_OUTPUT
              echo "ssh_user=${{ secrets.WSO2_SSH_USERNAME_UAT_NODE_2 }}" >> $GITHUB_OUTPUT
              echo "ssh_pass=${{ secrets.WSO2_SSH_PASSWORD_UAT_NODE_2 }}" >> $GITHUB_OUTPUT
              echo "inventory_file=UAT_NODE_2.yml" >> $GITHUB_OUTPUT
              echo "group_vars_file=UAT_NODE_2.yml" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "::error::Unknown environment: $ENVIRONMENT"
              exit 1
              ;;
          esac

      - name: Verify SSH access
        run: |
          sshpass -p "${{ steps.env-secrets.outputs.ssh_pass }}" ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            -o BatchMode=no \
            -o PubkeyAuthentication=no \
            "${{ steps.env-secrets.outputs.ssh_user }}@${{ steps.env-secrets.outputs.ssh_host }}" "echo 'Connection successful'" \
            && echo "âœ“ SSH access verified" \
            || { echo "âœ— SSH access failed"; exit 1; }

      - name: Verify dry run path exists on server
        run: |
          sshpass -p "${{ steps.env-secrets.outputs.ssh_pass }}" ssh -o StrictHostKeyChecking=no \
            "${{ steps.env-secrets.outputs.ssh_user }}@${{ steps.env-secrets.outputs.ssh_host }}" \
            "test -d '${{ inputs.dry_run_path }}' && echo 'âœ“ Dry run path exists' || { echo 'âœ— Dry run path not found: ${{ inputs.dry_run_path }}'; exit 1; }"

  # ============================================================
  # Job 2: Approval gate
  # Configure in: Settings â†’ Environments â†’ Add reviewers
  # ============================================================
  approve:
    name: Approval Gate
    needs: validate
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}-approval
    steps:
      - name: Approved
        run: |
          echo "âœ“ Deployment to ${{ inputs.environment }} approved by ${{ github.actor }}"

  # ============================================================
  # Job 3: Auto-resolve conflicts
  # Copies .original â†’ .final for matching patterns (keep ours)
  # Runs BEFORE stopping server (no server restart needed)
  # ============================================================
  resolve-conflicts:
    name: Auto-Resolve Conflicts
    needs: [validate, approve]
    runs-on: [self-hosted, ansible]
    outputs:
      total_conflicts: ${{ steps.resolve.outputs.total_conflicts }}
      auto_resolved: ${{ steps.resolve.outputs.auto_resolved }}
      remaining: ${{ steps.resolve.outputs.remaining }}
      resolved_files: ${{ steps.resolve.outputs.resolved_files }}
      remaining_files: ${{ steps.resolve.outputs.remaining_files }}
      resolve_result: ${{ steps.resolve.outputs.result }}
    steps:
      - name: Auto-resolve conflicts on server
        id: resolve
        run: |
          DRY_RUN_PATH="${{ inputs.dry_run_path }}"
          PATTERNS="${{ inputs.auto_resolve_patterns }}"

          echo "============================================"
          echo "Auto-Resolving Conflicts"
          echo "============================================"
          echo "Path:     $DRY_RUN_PATH"
          echo "Patterns: $PATTERNS"
          echo "============================================"

          # Build the remote script
          # .original = our current customized file
          # .new      = incoming update version
          # .final    = resolved version (what --continue will use)
          # Strategy: copy .original â†’ .final for matching patterns (keep ours)

          REMOTE_SCRIPT=$(cat << 'REMOTE_EOF'
          #!/bin/bash
          set -euo pipefail

          DRY_RUN_PATH="$1"
          PATTERNS="$2"

          if [ ! -d "$DRY_RUN_PATH" ]; then
            echo "ERROR: Conflicts directory not found: $DRY_RUN_PATH"
            exit 1
          fi

          IFS=',' read -ra PATTERN_LIST <<< "$PATTERNS"
          for i in "${!PATTERN_LIST[@]}"; do
            PATTERN_LIST[$i]=$(echo "${PATTERN_LIST[$i]}" | xargs)
          done

          TOTAL=0
          AUTO_RESOLVED=0
          REMAINING=0
          RESOLVED_LIST=""
          REMAINING_LIST=""

          while IFS= read -r original_file; do
            [ -z "$original_file" ] && continue

            TOTAL=$((TOTAL + 1))

            base_file="${original_file%.original}"
            base_name=$(basename "$base_file")
            rel_path="${original_file#$DRY_RUN_PATH/}"
            rel_path="${rel_path%.original}"
            final_file="${base_file}.final"

            MATCHED=false
            for pattern in "${PATTERN_LIST[@]}"; do
              case "$base_name" in
                $pattern)
                  MATCHED=true
                  break
                  ;;
              esac
            done

            if [ "$MATCHED" = "true" ]; then
              AUTO_RESOLVED=$((AUTO_RESOLVED + 1))
              cp "$original_file" "$final_file"
              echo "[RESOLVED] $rel_path (kept ours: .original â†’ .final)"

              [ -n "$RESOLVED_LIST" ] && RESOLVED_LIST="${RESOLVED_LIST}, ${rel_path}" || RESOLVED_LIST="$rel_path"
            else
              REMAINING=$((REMAINING + 1))
              echo "[MANUAL]   $rel_path (needs manual resolution)"

              [ -n "$REMAINING_LIST" ] && REMAINING_LIST="${REMAINING_LIST}, ${rel_path}" || REMAINING_LIST="$rel_path"
            fi

          done < <(find "$DRY_RUN_PATH" -name "*.original" -type f 2>/dev/null | sort)

          echo ""
          echo "============================================"
          echo "RESOLUTION SUMMARY"
          echo "============================================"
          echo "Total conflicts:  $TOTAL"
          echo "Auto-resolved:    $AUTO_RESOLVED (kept ours)"
          echo "Remaining:        $REMAINING (manual needed)"
          echo "============================================"

          echo "OUTPUT_TOTAL=$TOTAL"
          echo "OUTPUT_AUTO_RESOLVED=$AUTO_RESOLVED"
          echo "OUTPUT_REMAINING=$REMAINING"
          echo "OUTPUT_RESOLVED_LIST=$RESOLVED_LIST"
          echo "OUTPUT_REMAINING_LIST=$REMAINING_LIST"
          REMOTE_EOF

          RESULT=$(sshpass -p "${{ needs.validate.outputs.ssh_pass }}" ssh -o StrictHostKeyChecking=no \
            "${{ needs.validate.outputs.ssh_user }}@${{ needs.validate.outputs.ssh_host }}" \
            "bash -s -- '$DRY_RUN_PATH' '$PATTERNS'" <<< "$REMOTE_SCRIPT")

          echo "$RESULT"

          # Parse outputs
          TOTAL=$(echo "$RESULT" | grep "^OUTPUT_TOTAL=" | cut -d= -f2)
          AUTO_RESOLVED=$(echo "$RESULT" | grep "^OUTPUT_AUTO_RESOLVED=" | cut -d= -f2)
          REMAINING=$(echo "$RESULT" | grep "^OUTPUT_REMAINING=" | cut -d= -f2)
          RESOLVED_LIST=$(echo "$RESULT" | grep "^OUTPUT_RESOLVED_LIST=" | cut -d= -f2-)
          REMAINING_LIST=$(echo "$RESULT" | grep "^OUTPUT_REMAINING_LIST=" | cut -d= -f2-)

          {
            echo "total_conflicts=${TOTAL:-0}"
            echo "auto_resolved=${AUTO_RESOLVED:-0}"
            echo "remaining=${REMAINING:-0}"
            echo "resolved_files=${RESOLVED_LIST:-None}"
            echo "remaining_files=${REMAINING_LIST:-None}"
          } >> $GITHUB_OUTPUT

          # Fail if there are remaining unresolved conflicts
          if [ "${REMAINING:-0}" -gt 0 ]; then
            echo "::error::${REMAINING} conflict(s) still need manual resolution. Resolve them on the server, then re-run."
            echo "result=partial" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "âœ“ All conflicts auto-resolved"
          echo "result=success" >> $GITHUB_OUTPUT

  # ============================================================
  # Job 4: Stop WSO2 server
  # Only runs if all conflicts are resolved
  # ============================================================
  stop-server:
    name: Stop WSO2 Server
    needs: [validate, resolve-conflicts]
    runs-on: [self-hosted, ansible]
    outputs:
      stop_result: ${{ steps.stop.outputs.result }}
    steps:
      - name: Setup workspace
        id: setup
        run: |
          WORKSPACE="${{ github.workspace }}/${{ github.run_id }}-update-apply"
          mkdir -p "$WORKSPACE"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          path: ${{ steps.setup.outputs.workspace }}

      - name: Generate dynamic inventory
        run: |
          mkdir -p ${{ steps.setup.outputs.workspace }}/ansible/inventory

          cat > ${{ steps.setup.outputs.workspace }}/ansible/inventory/dynamic.ini << EOF
          [wso2_servers]
          wso2-server ansible_host=${{ needs.validate.outputs.ssh_host }} ansible_user=${{ needs.validate.outputs.ssh_user }} ansible_password=${{ needs.validate.outputs.ssh_pass }}
          EOF

      - name: Stop WSO2 IAM server
        id: stop
        working-directory: ${{ steps.setup.outputs.workspace }}/ansible
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          ANSIBLE_FORKS: "1"
        run: |
          set +e

          GROUP_VARS_FILE="group_vars/${{ needs.validate.outputs.group_vars_file }}"

          echo "Stopping WSO2 IAM server on ${{ needs.validate.outputs.environment }}..."

          ansible-playbook playbooks/stop-server.yml \
            -i "inventory/dynamic.ini" \
            -f 1 \
            -e "@group_vars/all.yml" \
            -e "@$GROUP_VARS_FILE" \
            -e "ansible_host_ip=${{ needs.validate.outputs.ssh_host }}" \
            -e "ansible_ssh_user=${{ needs.validate.outputs.ssh_user }}" \
            -e "ansible_ssh_pass=${{ needs.validate.outputs.ssh_pass }}" \
            -v 2>&1 | tee /tmp/stop-server.log

          EXIT_CODE=${PIPESTATUS[0]}

          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ“ Server stopped successfully"
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "âœ— Failed to stop server (exit code: $EXIT_CODE)"
            echo "result=failure" >> $GITHUB_OUTPUT
            exit $EXIT_CODE
          fi

  # ============================================================
  # Job 5: Apply update (--continue)
  # ============================================================
  apply-update:
    name: Apply Update (Continue)
    needs: [validate, stop-server]
    runs-on: [self-hosted, ansible]
    outputs:
      apply_result: ${{ steps.apply.outputs.result }}
      apply_exit_code: ${{ steps.apply.outputs.exit_code }}
      previous_level: ${{ steps.apply.outputs.previous_level }}
      new_level: ${{ steps.apply.outputs.new_level }}
      product: ${{ steps.apply.outputs.product }}
      product_version: ${{ steps.apply.outputs.product_version }}
    steps:
      - name: Setup workspace
        id: setup
        run: |
          WORKSPACE="${{ github.workspace }}/${{ github.run_id }}-update-apply"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          path: ${{ steps.setup.outputs.workspace }}

      - name: Generate dynamic inventory
        run: |
          mkdir -p ${{ steps.setup.outputs.workspace }}/ansible/inventory

          cat > ${{ steps.setup.outputs.workspace }}/ansible/inventory/dynamic.ini << EOF
          [wso2_servers]
          wso2-server ansible_host=${{ needs.validate.outputs.ssh_host }} ansible_user=${{ needs.validate.outputs.ssh_user }} ansible_password=${{ needs.validate.outputs.ssh_pass }}
          EOF

      - name: Apply update with --continue
        id: apply
        working-directory: ${{ steps.setup.outputs.workspace }}/ansible
        env:
          WSO2_UPDATE_USERNAME: ${{ secrets.WSO2_SECURE_UPDATE_USERNAME }}
          WSO2_UPDATE_PASSWORD: ${{ secrets.WSO2_SECURE_UPDATE_PASSWORD }}
          ANSIBLE_HOST_KEY_CHECKING: "False"
          ANSIBLE_FORKS: "1"
        run: |
          set +e

          GROUP_VARS_FILE="group_vars/${{ needs.validate.outputs.group_vars_file }}"

          echo "============================================"
          echo "Applying update with --continue"
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "============================================"

          ansible-playbook playbooks/apply-update.yml \
            -i "inventory/dynamic.ini" \
            -f 1 \
            -e "@group_vars/all.yml" \
            -e "@$GROUP_VARS_FILE" \
            -e "ansible_host_ip=${{ needs.validate.outputs.ssh_host }}" \
            -e "ansible_ssh_user=${{ needs.validate.outputs.ssh_user }}" \
            -e "ansible_ssh_pass=${{ needs.validate.outputs.ssh_pass }}" \
            -e "wso2_update_username=$WSO2_UPDATE_USERNAME" \
            -e "wso2_update_password=$WSO2_UPDATE_PASSWORD" \
            -e "update_action=continue" \
            -v 2>&1 | tee /tmp/apply-update.log

          ANSIBLE_EXIT_CODE=${PIPESTATUS[0]}

          echo "exit_code=$ANSIBLE_EXIT_CODE" >> $GITHUB_OUTPUT

          # Parse apply report
          APPLY_REPORT=$(ls /tmp/wso2_apply_report_*.json 2>/dev/null | head -1)

          if [ -f "$APPLY_REPORT" ]; then
            cat "$APPLY_REPORT"
            echo "previous_level=$(jq -r '.previous_level // "Unknown"' "$APPLY_REPORT")" >> $GITHUB_OUTPUT
            echo "new_level=$(jq -r '.new_level // "Unknown"' "$APPLY_REPORT")" >> $GITHUB_OUTPUT
            echo "product=$(jq -r '.product // "Unknown"' "$APPLY_REPORT")" >> $GITHUB_OUTPUT
            echo "product_version=$(jq -r '.product_version // "Unknown"' "$APPLY_REPORT")" >> $GITHUB_OUTPUT
          else
            echo "::warning::Apply report not found"
            echo "previous_level=Unknown" >> $GITHUB_OUTPUT
            echo "new_level=Unknown" >> $GITHUB_OUTPUT
            echo "product=Unknown" >> $GITHUB_OUTPUT
            echo "product_version=Unknown" >> $GITHUB_OUTPUT
          fi

          if [ $ANSIBLE_EXIT_CODE -eq 0 ]; then
            echo "âœ“ Update applied successfully"
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "âœ— Update apply failed (exit code: $ANSIBLE_EXIT_CODE)"
            echo "result=failure" >> $GITHUB_OUTPUT
          fi

          exit $ANSIBLE_EXIT_CODE

  # ============================================================
  # Job 6: Start WSO2 server
  # Runs even if apply fails (to restore service)
  # ============================================================
  start-server:
    name: Start WSO2 Server
    needs: [validate, stop-server, apply-update]
    if: always() && needs.stop-server.result == 'success'
    runs-on: [self-hosted, ansible]
    outputs:
      start_result: ${{ steps.start.outputs.result }}
      health_check: ${{ steps.health.outputs.status }}
    steps:
      - name: Setup workspace
        id: setup
        run: |
          WORKSPACE="${{ github.workspace }}/${{ github.run_id }}-update-apply"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          path: ${{ steps.setup.outputs.workspace }}

      - name: Generate dynamic inventory
        run: |
          mkdir -p ${{ steps.setup.outputs.workspace }}/ansible/inventory

          cat > ${{ steps.setup.outputs.workspace }}/ansible/inventory/dynamic.ini << EOF
          [wso2_servers]
          wso2-server ansible_host=${{ needs.validate.outputs.ssh_host }} ansible_user=${{ needs.validate.outputs.ssh_user }} ansible_password=${{ needs.validate.outputs.ssh_pass }}
          EOF

      - name: Start WSO2 IAM server
        id: start
        working-directory: ${{ steps.setup.outputs.workspace }}/ansible
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          ANSIBLE_FORKS: "1"
        run: |
          set +e

          GROUP_VARS_FILE="group_vars/${{ needs.validate.outputs.group_vars_file }}"

          echo "Starting WSO2 IAM server on ${{ needs.validate.outputs.environment }}..."

          ansible-playbook playbooks/start-server.yml \
            -i "inventory/dynamic.ini" \
            -f 1 \
            -e "@group_vars/all.yml" \
            -e "@$GROUP_VARS_FILE" \
            -e "ansible_host_ip=${{ needs.validate.outputs.ssh_host }}" \
            -e "ansible_ssh_user=${{ needs.validate.outputs.ssh_user }}" \
            -e "ansible_ssh_pass=${{ needs.validate.outputs.ssh_pass }}" \
            -v 2>&1 | tee /tmp/start-server.log

          EXIT_CODE=${PIPESTATUS[0]}

          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ“ Server started successfully"
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "âœ— Failed to start server (exit code: $EXIT_CODE)"
            echo "result=failure" >> $GITHUB_OUTPUT
            exit $EXIT_CODE
          fi

      - name: Health check
        id: health
        if: steps.start.outputs.result == 'success'
        run: |
          echo "Waiting for server to be ready..."
          HOST="${{ needs.validate.outputs.ssh_host }}"
          MAX_RETRIES=30
          RETRY_INTERVAL=10

          for i in $(seq 1 $MAX_RETRIES); do
            HTTP_CODE=$(curl -sk -o /dev/null -w "%{http_code}" "https://${HOST}:9443/carbon/admin/login.jsp" 2>/dev/null || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ“ Health check passed (attempt $i/$MAX_RETRIES)"
              echo "status=healthy" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "Attempt $i/$MAX_RETRIES - HTTP $HTTP_CODE, retrying in ${RETRY_INTERVAL}s..."
            sleep $RETRY_INTERVAL
          done

          echo "âœ— Health check failed after $MAX_RETRIES attempts"
          echo "status=unhealthy" >> $GITHUB_OUTPUT

  # ============================================================
  # Job 7: Send Teams notification
  # ============================================================
  notify-teams:
    name: Send Teams Notification
    runs-on: ubuntu-latest
    needs: [validate, resolve-conflicts, apply-update, start-server]
    if: always()
    env:
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
    steps:
      - name: Install jq
        run: |
          INSTALL_DIR="/tmp/bin"
          mkdir -p "$INSTALL_DIR"

          if [ ! -x "$INSTALL_DIR/jq" ]; then
            curl -fsSL "https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64" -o "$INSTALL_DIR/jq"
            chmod +x "$INSTALL_DIR/jq"
          fi

          echo "$INSTALL_DIR" >> $GITHUB_PATH

      - name: Send Teams notification
        run: |
          if [ -z "$TEAMS_WEBHOOK_URL" ]; then
            echo "Teams webhook not configured, skipping"
            exit 0
          fi

          # --- Gather all outputs ---
          ENVIRONMENT="${{ inputs.environment }}"
          PATTERNS="${{ inputs.auto_resolve_patterns }}"

          # Resolve outputs
          RESOLVE_RESULT="${{ needs.resolve-conflicts.outputs.resolve_result }}"
          TOTAL_CONFLICTS="${{ needs.resolve-conflicts.outputs.total_conflicts }}"
          AUTO_RESOLVED="${{ needs.resolve-conflicts.outputs.auto_resolved }}"
          REMAINING="${{ needs.resolve-conflicts.outputs.remaining }}"
          RESOLVED_FILES="${{ needs.resolve-conflicts.outputs.resolved_files }}"
          REMAINING_FILES="${{ needs.resolve-conflicts.outputs.remaining_files }}"

          # Apply outputs
          APPLY_RESULT="${{ needs.apply-update.outputs.apply_result }}"
          PREVIOUS_LEVEL="${{ needs.apply-update.outputs.previous_level }}"
          NEW_LEVEL="${{ needs.apply-update.outputs.new_level }}"
          PRODUCT="${{ needs.apply-update.outputs.product }}"
          PRODUCT_VERSION="${{ needs.apply-update.outputs.product_version }}"

          # Server outputs
          START_RESULT="${{ needs.start-server.outputs.start_result }}"
          HEALTH_STATUS="${{ needs.start-server.outputs.health_check }}"

          # --- Determine overall status ---
          if [ "$RESOLVE_RESULT" = "partial" ]; then
            TITLE="âš ï¸ WSO2 IAM Update Blocked â€” Unresolved Conflicts"
            THEME_COLOR="FFA500"
            OVERALL_STATUS="Blocked (${REMAINING} file(s) need manual resolution)"
          elif [ "$APPLY_RESULT" = "success" ] && [ "$START_RESULT" = "success" ] && [ "$HEALTH_STATUS" = "healthy" ]; then
            TITLE="âœ… WSO2 IAM Update Applied Successfully"
            THEME_COLOR="28A745"
            OVERALL_STATUS="Success"
          elif [ "$APPLY_RESULT" = "success" ] && [ "$HEALTH_STATUS" != "healthy" ]; then
            TITLE="âš ï¸ WSO2 IAM Update Applied â€” Health Check Warning"
            THEME_COLOR="FFA500"
            OVERALL_STATUS="Applied (Health Check Failed)"
          elif [ "$APPLY_RESULT" = "success" ] && [ "$START_RESULT" != "success" ]; then
            TITLE="ðŸš¨ WSO2 IAM Update Applied â€” Server Start Failed"
            THEME_COLOR="DC3545"
            OVERALL_STATUS="Applied (Server Down)"
          else
            TITLE="ðŸš¨ WSO2 IAM Update Apply Failed"
            THEME_COLOR="DC3545"
            OVERALL_STATUS="Failed"
          fi

          APPLY_TIME=$(TZ='Asia/Colombo' date +"%Y-%m-%d %H:%M:%S IST")
          WORKFLOW_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # --- Build main facts ---
          FACTS=$(jq -n \
            --arg env "$ENVIRONMENT" \
            --arg product "$PRODUCT $PRODUCT_VERSION" \
            --arg prev "v$PREVIOUS_LEVEL" \
            --arg new "v$NEW_LEVEL" \
            --arg patterns "$PATTERNS" \
            --arg total "${TOTAL_CONFLICTS:-0} file(s)" \
            --arg auto "${AUTO_RESOLVED:-0} file(s)" \
            --arg remain "${REMAINING:-0} file(s)" \
            --arg apply_status "${APPLY_RESULT:-N/A}" \
            --arg server_status "${START_RESULT:-N/A}" \
            --arg health "${HEALTH_STATUS:-N/A}" \
            --arg overall "$OVERALL_STATUS" \
            --arg actor "${{ github.actor }}" \
            --arg time "$APPLY_TIME" \
            '[
              { "name": "ðŸŒ Environment", "value": ("**" + $env + "**") },
              { "name": "ðŸ–¥ï¸ Host", "value": "IAM" },
              { "name": "ðŸ“¦ Product", "value": $product },
              { "name": "ðŸ“ Previous Level", "value": $prev },
              { "name": "ðŸŽ¯ New Level", "value": $new },
              { "name": "ðŸ”§ Auto-Resolve Patterns", "value": $patterns },
              { "name": "ðŸ“‹ Total Conflicts", "value": $total },
              { "name": "âœ… Auto-Resolved (kept ours)", "value": $auto },
              { "name": "âš ï¸ Manual Resolution Needed", "value": $remain },
              { "name": "ðŸ“‹ Apply Status", "value": $apply_status },
              { "name": "ðŸ–¥ï¸ Server Status", "value": $server_status },
              { "name": "ðŸ’š Health Check", "value": $health },
              { "name": "ðŸ“Š Overall", "value": ("**" + $overall + "**") },
              { "name": "ðŸ‘¤ Applied By", "value": $actor },
              { "name": "ðŸ• Time", "value": $time }
            ]')

          # --- Build sections ---
          MAIN_SECTION=$(jq -n \
            --arg title "$TITLE" \
            --argjson facts "$FACTS" \
            '{
              "activityTitle": $title,
              "facts": $facts,
              "markdown": true
            }')

          SECTIONS="[$MAIN_SECTION]"

          # --- Auto-resolved files section ---
          if [ -n "$RESOLVED_FILES" ] && [ "$RESOLVED_FILES" != "None" ]; then
            RESOLVED_FACTS=$(echo "$RESOLVED_FILES" | tr ',' '\n' | sed 's/^ *//' | \
              jq -R -s -c 'split("\n") | map(select(length > 0)) | to_entries | map({ "name": ("âœ… " + ((.key + 1) | tostring)), "value": .value })')

            RESOLVED_SECTION=$(jq -n \
              --argjson facts "$RESOLVED_FACTS" \
              '{
                "activityTitle": "ðŸ“ Auto-Resolved Files (Kept Ours: .original â†’ .final)",
                "facts": $facts,
                "markdown": true
              }')

            SECTIONS=$(echo "$SECTIONS" | jq --argjson s "$RESOLVED_SECTION" '. + [$s]')
          fi

          # --- Remaining unresolved files section ---
          if [ -n "$REMAINING_FILES" ] && [ "$REMAINING_FILES" != "None" ]; then
            REMAINING_FACTS=$(echo "$REMAINING_FILES" | tr ',' '\n' | sed 's/^ *//' | \
              jq -R -s -c 'split("\n") | map(select(length > 0)) | to_entries | map({ "name": ("ðŸ”´ " + ((.key + 1) | tostring)), "value": .value })')

            REMAINING_SECTION=$(jq -n \
              --argjson facts "$REMAINING_FACTS" \
              '{
                "activityTitle": "ðŸš¨ Unresolved Files (Manual Resolution Required)",
                "facts": $facts,
                "markdown": true
              }')

            SECTIONS=$(echo "$SECTIONS" | jq --argjson s "$REMAINING_SECTION" '. + [$s]')
          fi

          # --- Warning section if server is down ---
          if { [ "$START_RESULT" != "success" ] && [ "$RESOLVE_RESULT" != "partial" ]; } || [ "$HEALTH_STATUS" = "unhealthy" ]; then
            WARNING_SECTION=$(jq -n '{
              "activityTitle": "ðŸš¨ ACTION REQUIRED",
              "text": "The server may not be running correctly. Please check the server status immediately and perform manual intervention if needed.",
              "markdown": true
            }')
            SECTIONS=$(echo "$SECTIONS" | jq --argjson ws "$WARNING_SECTION" '. + [$ws]')
          fi

          # --- Blocked hint if unresolved conflicts ---
          if [ "$RESOLVE_RESULT" = "partial" ]; then
            HINT_SECTION=$(jq -n '{
              "activityTitle": "ðŸ“Œ Next Steps",
              "text": "Some conflicts could not be auto-resolved. Manually resolve the remaining files on the server (copy .original â†’ .final to keep ours, or .new â†’ .final to accept the update), then re-run this workflow.",
              "markdown": true
            }')
            SECTIONS=$(echo "$SECTIONS" | jq --argjson s "$HINT_SECTION" '. + [$s]')
          fi

          # --- Action buttons ---
          ACTIONS=$(jq -n \
            --arg workflow_url "$WORKFLOW_URL" \
            '[
              {
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [{ "os": "default", "uri": $workflow_url }]
              }
            ]')

          # --- Build and send payload ---
          JSON_PAYLOAD=$(jq -n \
            --arg title "$TITLE" \
            --arg theme "$THEME_COLOR" \
            --argjson sections "$SECTIONS" \
            --argjson actions "$ACTIONS" \
            '{
              "@type": "MessageCard",
              "@context": "http://schema.org/extensions",
              "themeColor": $theme,
              "summary": $title,
              "sections": $sections,
              "potentialAction": $actions
            }')

          echo "Sending notification to Teams..."

          HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" \
            --proxy "${HTTPS_PROXY:-}" \
            --connect-timeout 30 \
            --max-time 60 \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            "$TEAMS_WEBHOOK_URL")

          HTTP_CODE=$(echo "$HTTP_RESPONSE" | tail -1)
          RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | head -n -1)

          echo "Response code: $HTTP_CODE"

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "::warning::Teams notification failed with code $HTTP_CODE: $RESPONSE_BODY"
          else
            echo "Teams notification sent successfully"
          fi

  # ============================================================
  # Job 8: Cleanup
  # ============================================================
  cleanup:
    name: Cleanup
    runs-on: [self-hosted, ansible]
    needs: [validate, resolve-conflicts, apply-update, start-server, notify-teams]
    if: always()
    steps:
      - name: Cleanup workspace
        run: |
          WORKSPACE="${{ github.workspace }}/${{ github.run_id }}-update-apply"
          [ -d "$WORKSPACE" ] && rm -rf "$WORKSPACE"
          rm -f /tmp/wso2_apply_report_*.json
          rm -f /tmp/apply-update.log
          rm -f /tmp/stop-server.log
          rm -f /tmp/start-server.log
